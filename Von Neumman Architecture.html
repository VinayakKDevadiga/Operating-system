Von Neumman Architecture
<a href="https://github.com/VinayakKDevadiga/Operating-system/blob/main/Screenshot%20from%202025-12-07%2022-24-06.png> Architecture diagram </a>
Video: https://youtu.be/j8NnE1YeSN0?si=UPmaLCIEINOMIK6k


  Process:
  program which is in an execution:

  New: in the New state, the process is created and its information is prepared by the operating system. Then it moves to the Ready state.
  Ready state: where it is loaded into main memory and placed inside the ready queue waiting for CPU time. 
  Running: When the CPU scheduler picks the process, it moves into the Running state and starts executing its instructions. 
  waiting : If during execution the process needs input/output or some external resource, it goes into the Waiting state until that operation is completed. 
  Ready: After the required operation completes, the process returns to the Ready state. 
  Terminated: Finally, when the process finishes execution, it enters the Terminated state, where all resources are released and the process is removed from the system.


  Comtext swiching:
  Once a process is created, the CPU will allocate a PCB (Process Control Block) for that process. The PCB stores all important information related to that process such as the memory being used, the registers‚Äô current values, the pointer to the memory block, and the address of the next instruction to be executed. Along with that, it also keeps information like process ID, process state, and CPU scheduling details so that the operating system can manage and restart the process correctly whenever needed.
  Process ID (PID)
‚Üí A unique number assigned to the process

‚úî Process State
‚Üí New, Ready, Running, Waiting, Terminated

‚úî Program Counter
‚Üí Holds address of the next instruction to execute

‚úî CPU Registers
‚Üí Values stored when process is paused (context switching)

‚úî Memory Information
‚Üí Base and limit addresses
‚Üí Page tables / segment tables

‚úî CPU Scheduling Information
‚Üí Priority
‚Üí Scheduling queues pointer
‚Üí Time quantum

‚úî I/O Information
‚Üí List of I/O devices assigned
‚Üí Files opened

‚úî Accounting Information
‚Üí CPU usage time
‚Üí Execution time
‚Üí Time limits

When a higher priority process needs to run due to an interrupt or system call, the operating system temporarily stops the currently running process. Before stopping it, the OS saves all the necessary information of the current process into its PCB. This includes register values, program counter, and other execution details. After saving this context, the OS switches to the higher priority process and starts its execution. Once that process finishes or its time slice ends, the OS uses the stored PCB information of the suspended process, restores its context, and resumes its execution from where it was stopped.



CPU scheduling:
  It is the basis for multiprogrammed operating systems.
---

# **üìù Multithreading vs Multiprocessing ‚Äî Teacher & Pencils Analogy**

---

## **1Ô∏è‚É£ Multithreading**

**Analogy:**

* **Teacher** ‚Üí Parent process
* **Students / children** ‚Üí Threads
* **Pencils** ‚Üí CPU cores
* **Encyclopedia / textbook** ‚Üí Shared memory / variables
* **Student notebook** ‚Üí TCB (Thread Control Block, stores stack, registers, PC)

**How it works:**

* All students (threads) work **inside the same classroom** (process memory).
* They share the **encyclopedia** (memory), so only one can read/write a page at a time (synchronized).
* Each student has **their own notebook** to track what they are doing (stack, PC).
* Teacher can assign **maximum students equal to pencils (CPU cores)** to work in parallel.
* If more students exist than pencils, they **wait their turn** (ready queue).

**Example:**

* Java program creates 10 threads
* CPU has 4 cores
* 4 threads run simultaneously
* Threads accessing same shared variable **pause only for that variable**
* Others continue working on different parts

‚úÖ True parallelism on multiple cores
‚úÖ Synchronization only when accessing shared memory

---

## **2Ô∏è‚É£ Multiprocessing**

**Analogy:**

* **Teacher** ‚Üí Main program
* **Students / children** ‚Üí Processes
* **Pencils** ‚Üí CPU cores
* **Encyclopedia** ‚Üí Each process has **its own copy of memory**
* **Student notebook** ‚Üí PCB (Process Control Block)

**How it works:**

* Each student (process) works **in a separate classroom** (separate memory).
* They **do not share the encyclopedia** by default ‚Üí cannot access each other‚Äôs memory easily.
* Each process has its **own notebook** (PCB) with all resources and execution info.
* Teacher can assign **one student per pencil** (one process per core)
* If more processes than pencils ‚Üí extra processes wait

**Example:**

* 4 CPU cores, 4 processes
* Each core runs 1 process simultaneously
* Processes run independently, do not share memory
* Communication requires IPC (sending notes between classrooms)

‚úÖ True parallelism
‚úÖ No risk of race conditions in memory

---

## **3Ô∏è‚É£ Why Python is not efficient for CPU-bound multithreading**

**Analogy:**

* Python (CPython) has **GIL ‚Äî Global Interpreter Lock**
* Even if there are 4 pencils (cores) and 10 students (threads), **only one student can write at a time**, even if others don‚Äôt use the encyclopedia.
* Others **wait their turn**, creating a bottleneck.
* Safe memory access is guaranteed, but **true parallel execution for CPU-heavy tasks is blocked**.

**Java vs Python (CPU-bound):**

| Feature         | Java Threads         | Python Threads (CPython)         |
| --------------- | -------------------- | -------------------------------- |
| Parallelism     | True, max = cores    | Only 1 thread executes at a time |
| Shared Memory   | Shared among threads | Shared among threads (safe)      |
| CPU-bound Tasks | Efficient            | Inefficient (GIL limits)         |
| I/O-bound Tasks | Efficient            | Efficient                        |

‚úÖ Python threads are still useful for **I/O tasks** (network, disk)
‚úÖ For CPU-heavy work, Python uses **multiprocessing** to bypass GIL

---

## **4Ô∏è‚É£ Final Summary in One Line Each**

* **Multithreading** ‚Üí Threads share memory, TCB per thread, run in parallel on cores, pause only for shared data.
* **Multiprocessing** ‚Üí Processes have separate memory, PCB per process, run independently on cores.
* **Python GIL** ‚Üí Only one thread executes at a time ‚Üí limits CPU-bound efficiency.
* **Java threads** ‚Üí True parallel execution ‚Üí more efficient for CPU-bound tasks.

---
